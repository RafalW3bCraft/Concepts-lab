<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,viewport-fit=cover" />
<title>Eyes: Emotion Awakening</title>
<meta name="theme-color" content="#0a0f14"/>
<style>
  :root{
    --bg:#070b10; --panel:#0b1420; --ink:#dff7ff; --muted:#8fb3c9;
    --acc:#00ffc6; --edge:#1a374a; --edge2:#224e65;
    --good:#24e07a; --warn:#ffd166; --bad:#ff5666;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; background:
      radial-gradient(1200px 600px at 110% -10%, rgba(0,255,198,.12), transparent),
      radial-gradient(1000px 500px at -10% 110%, rgba(255,61,129,.10), transparent),
      #061018; color:var(--ink);
    font-family: Inter, ui-sans-serif, system-ui, Segoe UI, Roboto, Helvetica, Arial, Apple Color Emoji, Noto Color Emoji;
    overflow:hidden;
  }
  header{
    position:fixed; inset:0 0 auto 0; z-index:20;
    display:flex; gap:10px; align-items:center; padding:10px 12px;
    background:linear-gradient(180deg,#08121b,#091621); border-bottom:1px solid var(--edge);
  }
  .brand{display:flex; gap:10px; align-items:center}
  .brand .logo{font-size:22px; filter:drop-shadow(0 0 8px rgba(0,255,198,.35))}
  h1{margin:0; font-size:16px; letter-spacing:.5px; color:var(--acc)}
  .right{margin-left:auto; display:flex; gap:8px; align-items:center}
  .pill{padding:6px 10px; border:1px solid var(--edge2); border-radius:999px; background:#0c1c28; color:#bfeaff; font-size:12px}

  .wrap{position:fixed; inset:52px 0 0 0; display:grid; grid-template-columns:1fr 360px}
  @media(max-width:1024px){ .wrap{grid-template-columns:1fr} }

  /* Camera + Overlay */
  .stage{position:relative; background:#000}
  video, canvas{position:absolute; inset:0; width:100%; height:100%; object-fit:cover}
  #video{transform:scaleX(-1); background:#1a1a1a} /* mirror for selfie by default */
  canvas{pointer-events:none; mix-blend-mode:screen}
  .hud{position:absolute; top:8px; left:8px; right:8px; display:flex; justify-content:space-between; gap:8px; pointer-events:none}
  .tag{background:#0a1722b3; border:1px solid var(--edge2); color:#eaffff; padding:6px 10px; border-radius:10px; font-size:12px}

  /* Control panel */
  .panel{
    background:linear-gradient(180deg,#0a141d,#0b1721);
    border-left:1px solid var(--edge);
    display:flex; flex-direction:column; gap:10px; padding:12px; overflow:auto;
  }
  .card{border:1px solid var(--edge); border-radius:14px; overflow:hidden; background:#0a131c}
  .card h2{margin:0; padding:10px 12px; border-bottom:1px dashed var(--edge2); font-size:13px; color:#9fe6ff}
  .pad{padding:10px 12px}
  .row{display:flex; gap:8px; align-items:center; flex-wrap:wrap}
  .col{display:flex; flex-direction:column; gap:8px}
  .btn{cursor:pointer; border:1px solid var(--edge2); background:#0f1e2a; color:#e7fbff; padding:10px 12px; border-radius:12px; transition:.15s transform}
  .btn:active{transform:translateY(1px)}
  .btn.primary{background:linear-gradient(180deg,#00ffc6,#00d3a7); color:#00332a; border-color:#00d3b7; font-weight:800}
  .btn.ghost{background:transparent}
  .btn.warn{background:#2b1f0b; border-color:#6b4d1a; color:#ffe7b3}
  select,input[type=range]{width:100%; accent-color:#00e6be}
  input[type=range]{appearance:none; height:4px; background:#122a3a; border-radius:999px}
  input[type=range]::-webkit-slider-thumb{appearance:none; width:18px; height:18px; border-radius:50%; background:#00ffc6; border:2px solid #003229}
  .muted{color:var(--muted); font-size:12px}

  .thumbs{display:grid; grid-template-columns:repeat(4,1fr); gap:8px}
  .thumb{aspect-ratio:1/1; border:1px solid var(--edge); border-radius:10px; overflow:hidden; background:#08131c; display:grid; place-items:center; cursor:pointer}
  .thumb.active{box-shadow:0 0 0 2px #00ffc6 inset}
  .eyesLegend{display:grid; grid-template-columns:1fr 1fr; gap:8px}
  .eyesLegend div{background:#08131c; border:1px solid var(--edge); border-radius:8px; padding:8px; font-size:12px}

  /* Toast */
  .toast{position:fixed; left:50%; bottom:18px; transform:translateX(-50%); background:#081620; color:#defcff; border:1px solid var(--edge2); border-radius:12px; padding:10px 14px; box-shadow:0 10px 30px rgba(0,0,0,.45); opacity:0; pointer-events:none; transition:.18s opacity,.18s transform; z-index:40}
  .toast.show{opacity:1; transform:translateX(-50%) translateY(-6px)}
</style>
</head>
<body>
<header>
  <div class="brand"><div class="logo">üëÅÔ∏è‚Äçüó®Ô∏è</div><h1>Eyes: Emotion Awakening</h1><div class="pill">on-device AR</div></div>
  <div class="right">
    <div id="status" class="pill">Loading‚Ä¶</div>
    <button id="switchCam" class="btn ghost">üîÅ Camera</button>
    <button id="mirrorBtn" class="btn ghost">ü™û Mirror</button>
    <button id="shotBtn" class="btn primary">üì∏ Capture</button>
  </div>
</header>

<div class="wrap">
  <section class="stage">
    <video id="video" autoplay playsinline muted></video>
    <canvas id="fx"></canvas>
    <div class="hud">
      <div class="tag">Emotion: <b id="emo">‚Äî</b></div>
      <div class="tag">Persona: <b id="personaNow">Auto</b></div>
      <div class="tag">üëÅÔ∏è Live Preview: <b id="liveMode">ON</b></div>
    </div>
  </section>

  <aside class="panel">
    <div class="card">
      <h2>Persona & Emotion</h2>
      <div class="pad col">
        <div class="row">
          <label class="muted">Mode</label>
          <select id="personaSel">
            <option value="auto">Auto (map from emotion)</option>
            <option value="apollo">Apollo ‚Äî radiant gold</option>
            <option value="odin">Odin ‚Äî icy blue</option>
            <option value="hades">Hades ‚Äî void purple</option>
            <option value="shiva">Shiva ‚Äî sapphire</option>
            <option value="medusa">Medusa ‚Äî emerald</option>
            <option value="ra">Ra ‚Äî sunfire</option>
            <option value="amaterasu">Amaterasu ‚Äî white sun</option>
            <option value="anubis">Anubis ‚Äî amber</option>
          </select>
        </div>
        <div class="eyesLegend">
          <div>Auto mapping:<br/>
            üòä Happy ‚Üí Apollo<br/>
            üò° Angry ‚Üí Ares/Anubis<br/>
            üòÆ Surprise ‚Üí Zeus/Odin<br/>
            üòê Neutral/Calm ‚Üí Athena/Shiva<br/>
            üò¢ Sad ‚Üí Hades<br/>
            üò® Fear ‚Üí Medusa
          </div>
          <div>Tips:<br/>Good light ‚Ä¢ Face camera ‚Ä¢ Keep eyes visible ‚Ä¢ Blink naturally</div>
        </div>
      </div>
    </div>

    <div class="card">
      <h2>Eye FX Settings</h2>
      <div class="pad col">
        <div><span class="muted">Glow Intensity</span><input id="intensity" type="range" min="0" max="1.5" step="0.05" value="0.9"/></div>
        <div><span class="muted">Iris Size</span><input id="iris" type="range" min="0.8" max="2.0" step="0.05" value="1.1"/></div>
        <div><span class="muted">Bloom</span><input id="bloom" type="range" min="0" max="1.5" step="0.05" value="1.0"/></div>
        <div class="row">
          <button id="toggleSparks" class="btn">‚ú® Sparks On</button>
          <button id="toggleAura" class="btn">üúÇ Aura On</button>
        </div>
        <div class="row" style="margin-top:8px">
          <button id="toggleLive" class="btn primary">üëÅÔ∏è Live Preview On</button>
        </div>
      </div>
    </div>

    <div class="card">
      <h2>Gallery</h2>
      <div class="pad">
        <div id="gallery" class="thumbs"></div>
        <div class="muted" style="margin-top:6px">Captures are stored only on your device.</div>
      </div>
    </div>
  </aside>
</div>

<div id="toast" class="toast">Toast</div>

<script type="module">

import {FaceLandmarker, FilesetResolver} from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.15/vision_bundle.mjs";

const els = {
  video: document.getElementById('video'),
  fx: document.getElementById('fx'),
  emo: document.getElementById('emo'),
  personaNow: document.getElementById('personaNow'),
  personaSel: document.getElementById('personaSel'),
  status: document.getElementById('status'),
  intensity: document.getElementById('intensity'),
  iris: document.getElementById('iris'),
  bloom: document.getElementById('bloom'),
  toggleSparks: document.getElementById('toggleSparks'),
  toggleAura: document.getElementById('toggleAura'),
  toggleLive: document.getElementById('toggleLive'),
  switchCam: document.getElementById('switchCam'),
  mirrorBtn: document.getElementById('mirrorBtn'),
  shotBtn: document.getElementById('shotBtn'),
  gallery: document.getElementById('gallery'),
  toast: document.getElementById('toast'),
  liveMode: document.getElementById('liveMode')
};
const ctx = els.fx.getContext('2d', {alpha:true, desynchronized:true, willReadFrequently:false});

let landmarker;
let running = true;
let facingMode = "user";      
let mirrored = true;
let lastVideoTime = 0;
let sparkOn = true, auraOn = true;
let livePreview = true;       
let lastRenderTime = 0;       
let faceDetected = false;     
let lastEmotionUpdate = 0;    

// Persona definitions (eye color, rim, aura color, sparks)
const PERSONAS = {
  apollo:   {iris:"#ffd166", rim:"#fff6a8", aura:"#ffbf69", spark:"#ffe29e"},
  odin:     {iris:"#78d4ff", rim:"#c6f1ff", aura:"#7fd2ff", spark:"#bbecff"},
  hades:    {iris:"#9b72ff", rim:"#e0d1ff", aura:"#b18dff", spark:"#d8c6ff"},
  shiva:    {iris:"#5ab3ff", rim:"#c2e7ff", aura:"#5ac8ff", spark:"#a9e1ff"},
  medusa:   {iris:"#3ee486", rim:"#c8ffd1", aura:"#58ffb0", spark:"#caffd8"},
  ra:       {iris:"#ffb200", rim:"#ffe69b", aura:"#ff9d00", spark:"#ffd24d"},
  amaterasu:{iris:"#ffffff", rim:"#ffffff", aura:"#fff7d1", spark:"#ffffff"},
  anubis:   {iris:"#ff8c2a", rim:"#ffd2a3", aura:"#ff9e4d", spark:"#ffd9a8"},
  ares:     {iris:"#ff4757", rim:"#ffc2c7", aura:"#ff6b6b", spark:"#ffc4c7"},
  athena:   {iris:"#b7c6d9", rim:"#eaf2ff", aura:"#bcd0e8", spark:"#e9f3ff"},
  zeus:     {iris:"#9be7ff", rim:"#e7fbff", aura:"#a1e9ff", spark:"#e6fbff"}
};

function personaFromEmotion(e){
  switch(e){
    case "happy": return "apollo";
    case "angry": return "ares";
    case "surprised": return "zeus";
    case "sad": return "hades";
    case "fearful": return "medusa";
    case "disgusted": return "anubis";
    case "neutral":
    default: return "shiva";
  }
}

const toast=(m)=>{ els.toast.textContent=m; els.toast.classList.add('show'); setTimeout(()=>els.toast.classList.remove('show'),1400); };

// Camera
async function openCamera(){
  if(!navigator.mediaDevices?.getUserMedia){ 
    els.status.textContent="Camera not supported"; 
    toast("Camera not supported in this browser");
    return; 
  }
  try{
    els.status.textContent = "Requesting camera access...";
    console.log("Requesting camera with facingMode:", facingMode);
    
    const constraints = {
      video: {
        facingMode: facingMode,
        width: {ideal: 1280, min: 640}, 
        height: {ideal: 720, min: 480},
        frameRate: {ideal: 30, max: 60}
      },
      audio: false
    };
    
    const stream = await navigator.mediaDevices.getUserMedia(constraints);
    els.video.srcObject = stream;
    
    await new Promise((resolve, reject) => {
      els.video.onloadedmetadata = () => {
        console.log("Video metadata loaded:", els.video.videoWidth, "x", els.video.videoHeight);
        resolve();
      };
      els.video.onerror = reject;
    });
    
    await els.video.play();
    console.log("Video playing:", els.video.readyState);
    
    sizeCanvas();
    els.status.textContent = "Camera ready - point at your face";
    toast("Camera access granted! Point camera at your face");
    
  }catch(e){
    console.error("Camera error details:", e.name, e.message, e);
    if(e.name === 'NotAllowedError') {
      els.status.textContent="Camera permission denied";
      toast("üì∏ Please allow camera access and refresh the page");
    } else if(e.name === 'NotFoundError') {
      els.status.textContent="No camera found";
      toast("üì∑ No camera device found on this device");
    } else if(e.name === 'OverconstrainedError') {
      els.status.textContent="Trying simpler camera settings...";
      toast("üì± Camera settings not supported, trying basic mode");
      try {
        console.log("Attempting basic camera constraints");
        const basicStream = await navigator.mediaDevices.getUserMedia({
          video: {
            width: {ideal: 640, min: 320},
            height: {ideal: 480, min: 240}
          },
          audio: false
        });
        els.video.srcObject = basicStream;
        
        await new Promise((resolve, reject) => {
          els.video.onloadedmetadata = () => {
            console.log("Basic video ready:", els.video.videoWidth, "x", els.video.videoHeight);
            resolve();
          };
          els.video.onerror = reject;
        });
        
        await els.video.play();
        sizeCanvas();
        els.status.textContent = "Camera ready with basic settings";
        toast("‚úÖ Camera working in basic mode");
      } catch(basicError) {
        console.error("Basic camera error:", basicError);
        els.status.textContent = "Camera initialization failed";
        toast("‚ùå Camera completely failed to initialize");
      }
    } else if(e.name === 'NotReadableError') {
      els.status.textContent="Camera in use by another app";
      toast("üìπ Camera is being used by another application");
    } else {
      els.status.textContent="Camera error";
      toast(`‚ùå Camera error: ${e.message}`);
      console.error("Unhandled camera error:", e.name, e.message);
    }
  }
}
function sizeCanvas(){
  const rect = els.fx.getBoundingClientRect();
  els.fx.width = rect.width * devicePixelRatio;
  els.fx.height = rect.height * devicePixelRatio;
  ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
}

async function initFace(){
  try {
    els.status.textContent="Loading face model‚Ä¶";
    
    const cdnSources = [
      "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.15/wasm",
      "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/wasm",
      "https://unpkg.com/@mediapipe/tasks-vision@0.10.15/wasm"
    ];
    
    let fileset = null;
    let lastError = null;
    
    for (const cdnUrl of cdnSources) {
      try {
        console.log(`Trying CDN: ${cdnUrl}`);
        fileset = await FilesetResolver.forVisionTasks(cdnUrl);
        break;
      } catch (err) {
        console.warn(`CDN ${cdnUrl} failed:`, err);
        lastError = err;
        continue;
      }
    }
    
    if (!fileset) {
      throw new Error(`All CDN sources failed. Last error: ${lastError?.message || 'Unknown error'}`);
    }
    
    els.status.textContent="Creating face landmarker‚Ä¶";
    
    landmarker = await FaceLandmarker.createFromOptions(fileset, {
      baseOptions: {
        modelAssetPath: "https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task",
        delegate: "GPU"
      },
      runningMode: "VIDEO",
      numFaces: 1,
      outputFaceBlendshapes: true,
      outputFacialTransformationMatrixes: false,
      minFaceDetectionConfidence: 0.3,
      minFacePresenceConfidence: 0.3,
      minTrackingConfidence: 0.3
    });
    
    console.log("Face landmarker initialized successfully");
    els.status.textContent="Point your camera at your face";
    
  } catch (error) {
    console.error("Face landmarker initialization failed:", error);
    els.status.textContent = `Model loading failed: ${error.message}`;
    throw error;
  }
}

function estimateEmotion(blendshapes){
  try {
    if(!blendshapes?.categories?.length) {
      console.log("No blendshapes data available, using neutral");
      return {label:"neutral", score:0.3};
    }
    
    const get = (name) => {
      try {
        const category = blendshapes.categories.find(c => c.categoryName === name);
        const score = category?.score || 0;
        return Math.max(0, Math.min(1, score)); // Clamp between 0-1
      } catch (err) {
        console.warn(`Error getting blendshape ${name}:`, err);
        return 0;
      }
    };
    
    // Get facial action units with validation
    const smile = (get("mouthSmileLeft") + get("mouthSmileRight")) / 2;
    const mouthOpen = get("jawOpen");
    const eyeWide = (get("eyeWideLeft") + get("eyeWideRight")) / 2;
    const browDown = (get("browDownLeft") + get("browDownRight")) / 2;
    const mouthFrown = (get("mouthFrownLeft") + get("mouthFrownRight")) / 2;
    const browUp = get("browInnerUp");
    
    // Emotion scoring with smoothing
    const scores = {
      happy: Math.max(0, smile * 0.8 + Math.max(0, mouthOpen - 0.15) * 0.2),
      surprised: Math.max(0, eyeWide * 0.7 + mouthOpen * 0.5 + browUp * 0.2),
      angry: Math.max(0, browDown * 0.6 + Math.max(0, 0.25 - mouthOpen) * 0.2 + mouthFrown * 0.3),
      sad: Math.max(0, mouthFrown * 0.7 + Math.max(0, 0.3 - browUp) * 0.3),
      fearful: Math.max(0, eyeWide * 0.6 + browUp * 0.4 + Math.max(0, 0.3 - smile) * 0.2),
      disgusted: Math.max(0, (get("noseSneerLeft") + get("noseSneerRight")) / 2 * 0.6 + mouthFrown * 0.4),
      neutral: 0.25 // base neutral score
    };
    
    // Find the highest scoring emotion with minimum threshold
    let best = "neutral", bestScore = scores.neutral;
    for(const [emotion, score] of Object.entries(scores)){
      if(score > bestScore && score > 0.15) { // Minimum confidence threshold
        bestScore = score;
        best = emotion;
      }
    }
    
    if(bestScore > 0.3) {
      console.log(`Detected emotion: ${best} (${(bestScore * 100).toFixed(1)}%)`);
    }
    
    return {label: best, score: bestScore};
    
  } catch (error) {
    console.error("Error in emotion estimation:", error);
    return {label: "neutral", score: 0.3};
  }
}

function lerp(a,b,t){return a+(b-a)*t;}
function dist(ax,ay,bx,by){const dx=ax-bx, dy=ay-by; return Math.hypot(dx,dy);}
function hexToRGB(hex){
  const h = hex.replace('#',''); const n = parseInt(h,16);
  return {r:(n>>16)&255, g:(n>>8)&255, b:n&255};
}

// Render eyes + fx
function renderFX(landmarks, personaKey){
  const W = els.fx.width / devicePixelRatio;
  const H = els.fx.height / devicePixelRatio;
  ctx.clearRect(0,0,W,H);

  if(!landmarks?.length) {
    const cx = W / 2, cy = H / 2;
    const P = PERSONAS[personaKey] || PERSONAS["shiva"];
    const INT = parseFloat(els.intensity.value);
    
    ctx.save();
    ctx.globalCompositeOperation = "lighter";
    
    // Draw basic centered eye glow
    const baseR = Math.min(W, H) * 0.03;
    const leftX = cx - baseR * 3, rightX = cx + baseR * 3;
    
    function basicEyeGlow(x, y, r){
      const g1 = ctx.createRadialGradient(x, y, r * 0.1, x, y, r * 1.1);
      const cI = hexToRGB(P.iris); const cR = hexToRGB(P.rim);
      g1.addColorStop(0, `rgba(${cI.r},${cI.g},${cI.b},${0.4*INT})`);
      g1.addColorStop(0.6, `rgba(${cR.r},${cR.g},${cR.b},${0.2*INT})`);
      g1.addColorStop(1, `rgba(${cR.r},${cR.g},${cR.b},0)`);
      ctx.fillStyle = g1; ctx.beginPath(); ctx.arc(x, y, r * 1.1, 0, Math.PI * 2); ctx.fill();
    }
    
    basicEyeGlow(leftX, cy, baseR);
    basicEyeGlow(rightX, cy, baseR);
    
    ctx.restore();
    return;
  }

  const pts = landmarks[0]; // 468/478 points
  // Iris centers (MediaPipe indices 468 = left center, 473 = right center)
  const Lc = pts[468] || pts[468-10] || pts[159];
  const Rc = pts[473] || pts[473-10] || pts[386];
  if(!Lc || !Rc) return;

  // Project normalized coords accounting for object-fit: cover and mirroring
  function projectPoint(normalizedX, normalizedY) {
    const videoAR = els.video.videoWidth / els.video.videoHeight;
    const canvasAR = W / H;
    
    let x, y;
    
    if (videoAR > canvasAR) {
      const scale = H / els.video.videoHeight;
      const displayW = els.video.videoWidth * scale;
      const offsetX = (displayW - W) / 2;
      x = normalizedX * displayW - offsetX;
      y = normalizedY * H;
    } else {
      const scale = W / els.video.videoWidth;
      const displayH = els.video.videoHeight * scale;
      const offsetY = (displayH - H) / 2;
      x = normalizedX * W;
      y = normalizedY * displayH - offsetY;
    }
    
    if (mirrored) {
      x = W - x;
    }
    
    return { x, y };
  }

  const leftEye = projectPoint(Lc.x, Lc.y);
  const rightEye = projectPoint(Rc.x, Rc.y);
  
  const lx = leftEye.x, ly = leftEye.y;
  const rx = rightEye.x, ry = rightEye.y;

  // Estimate iris radius using nearby iris ring points
  const leftRing = pts[469] ? projectPoint(pts[469].x, pts[469].y) : null;
  const rightRing = pts[474] ? projectPoint(pts[474].x, pts[474].y) : null;
  
  const lR = leftRing ? dist(lx, ly, leftRing.x, leftRing.y) : Math.min(W, H) * 0.015;
  const rR = rightRing ? dist(rx, ry, rightRing.x, rightRing.y) : Math.min(W, H) * 0.015;

  // Persona colors
  const P = PERSONAS[personaKey] || PERSONAS["shiva"];
  const INT = parseFloat(els.intensity.value);
  const IRS = parseFloat(els.iris.value);
  const BLO = parseFloat(els.bloom.value);

  const irisR = lR*IRS, irisR2 = rR*IRS;

  ctx.save();
  ctx.globalCompositeOperation = "lighter";

  function eyeGlow(x,y,r){
    const g1 = ctx.createRadialGradient(x,y, r*0.1, x,y, r*1.1);
    const cI = hexToRGB(P.iris); const cR = hexToRGB(P.rim);
    g1.addColorStop(0, `rgba(${cI.r},${cI.g},${cI.b},${0.65*INT})`);
    g1.addColorStop(0.6, `rgba(${cR.r},${cR.g},${cR.b},${0.35*INT})`);
    g1.addColorStop(1, `rgba(${cR.r},${cR.g},${cR.b},0)`);
    ctx.fillStyle = g1; ctx.beginPath(); ctx.arc(x,y,r*1.1,0,Math.PI*2); ctx.fill();

    if(BLO>0.01){
      const g2 = ctx.createRadialGradient(x,y, r*0.8, x,y, r*(2.6+BLO));
      g2.addColorStop(0, `rgba(${cR.r},${cR.g},${cR.b},${0.18*BLO})`);
      g2.addColorStop(1, `rgba(${cR.r},${cR.g},${cR.b},0)`);
      ctx.fillStyle=g2; ctx.beginPath(); ctx.arc(x,y,r*(2.6+BLO),0,Math.PI*2); ctx.fill();
    }
  }
  eyeGlow(lx,ly,irisR);
  eyeGlow(rx,ry,irisR2);

  if(sparkOn){
    for(let i=0;i<6;i++){
      const jitter = (Math.random()-0.5)*8;
      spark(xrand(lx,8)+jitter, yrand(ly,8)+jitter, P.spark);
      spark(xrand(rx,8)+jitter, yrand(ry,8)+jitter, P.spark);
    }
  }

  if(auraOn){
    const cx = (lx+rx)/2, cy = (ly+ry)/2;
    const faceW = Math.abs(rx-lx)*3.2;
    const C = hexToRGB(P.aura);
    const g3 = ctx.createRadialGradient(cx,cy, faceW*0.2, cx,cy, faceW*1.8);
    g3.addColorStop(0, `rgba(${C.r},${C.g},${C.b},0.10)`);
    g3.addColorStop(1, `rgba(${C.r},${C.g},${C.b},0)`);
    ctx.fillStyle=g3; ctx.beginPath(); ctx.arc(cx,cy, faceW*1.8,0,Math.PI*2); ctx.fill();
  }

  ctx.restore();

  function spark(x,y,color){
    const c = hexToRGB(color);
    ctx.fillStyle = `rgba(${c.r},${c.g},${c.b},${0.25 + Math.random()*0.35})`;
    const r = 2 + Math.random()*3;
    ctx.beginPath(); ctx.arc(x + Math.random()*6-3, y + Math.random()*6-3, r, 0, Math.PI*2); ctx.fill();
  }
  function xrand(x,a){return x + (Math.random()-0.5)*a;}
  function yrand(y,a){return y + (Math.random()-0.5)*a;}
}

async function predictLoop(){
  if(!running){ requestAnimationFrame(predictLoop); return; }
  
  try {
    const now = els.video.currentTime;
    if(now !== lastVideoTime && landmarker && els.video.readyState === 4){
      lastVideoTime = now;
      
      const res = landmarker.detectForVideo(els.video, performance.now());
      
      if(!res) {
        console.warn("No detection result from landmarker");
        els.emo.textContent = "NO SIGNAL";
        renderFX([], "shiva"); 
        requestAnimationFrame(predictLoop);
        return;
      }
      
      const landmarks = res.faceLandmarks;
      const blend = res.faceBlendshapes?.[0];
      
      if(!landmarks || landmarks.length === 0) {
        if(faceDetected) {
          faceDetected = false;
          console.log("Face lost");
        }
        els.emo.textContent = "NO FACE DETECTED";
        if(livePreview) renderFX([], "shiva"); 
        requestAnimationFrame(predictLoop);
        return;
      }
      
      if(!faceDetected) {
        faceDetected = true;
        console.log(`Face detected with ${landmarks[0].length} landmarks`);
        toast("üé≠ Face detected! Live avatar preview active");
      }
      
      // Emotion analysis 
      let emo = "neutral";
      let confidence = 0;
      
      if(blend && blend.categories && blend.categories.length > 0) {
        const est = estimateEmotion(blend);
        emo = est.label;
        confidence = est.score;
        
        const currentTime = performance.now();
        if(currentTime - lastEmotionUpdate > 500) { 
          console.log(`Live emotion: ${emo} (${(confidence*100).toFixed(1)}%)`);
          lastEmotionUpdate = currentTime;
        }
      } else {
        emo = "neutral";
      }
      
      const confidenceText = confidence > 0.3 ? ` (${(confidence*100).toFixed(0)}%)` : '';
      els.emo.textContent = `${emo.toUpperCase()}${confidenceText}`;

      // Persona selection
      const selectVal = els.personaSel.value;
      const personaKey = (selectVal === "auto") ? personaFromEmotion(emo) : selectVal;
      els.personaNow.textContent = personaKey.charAt(0).toUpperCase() + personaKey.slice(1);

      const currentRenderTime = performance.now();
      if(livePreview && (currentRenderTime - lastRenderTime) > 16) { // ~60 FPS for smoother preview
        renderFX(landmarks, personaKey);
        lastRenderTime = currentRenderTime;
      }
    } else if(!landmarker) {
      els.emo.textContent = "INITIALIZING...";
    } else if(els.video.readyState < 4) {
      els.emo.textContent = "LOADING VIDEO...";
    }
  } catch(error) {
    console.error("Error in prediction loop:", error);
    els.emo.textContent = "ERROR";
    els.status.textContent = `Analysis error: ${error.message}`;
  }
  
  requestAnimationFrame(predictLoop);
}

window.addEventListener('resize', sizeCanvas);
els.switchCam.addEventListener('click', async ()=>{
  facingMode = (facingMode==="user") ? "environment" : "user";
  mirrored = (facingMode==="user");
  els.video.style.transform = mirrored ? "scaleX(-1)" : "scaleX(1)";
  await stopCamera(); await openCamera();
});
els.mirrorBtn.addEventListener('click', ()=>{
  mirrored = !mirrored; els.video.style.transform = mirrored ? "scaleX(-1)" : "scaleX(1)";
});
els.personaSel.addEventListener('change', ()=>{ /* live update via loop */ });

els.toggleSparks.addEventListener('click', ()=>{
  sparkOn = !sparkOn; els.toggleSparks.textContent = sparkOn ? "‚ú® Sparks On" : "‚ú® Sparks Off";
});
els.toggleAura.addEventListener('click', ()=>{
  auraOn = !auraOn; els.toggleAura.textContent = auraOn ? "üúÇ Aura On" : "üúÇ Aura Off";
});
els.toggleLive.addEventListener('click', ()=>{
  livePreview = !livePreview; 
  els.toggleLive.textContent = livePreview ? "üëÅÔ∏è Live Preview On" : "üëÅÔ∏è Live Preview Off";
  els.liveMode.textContent = livePreview ? "ON" : "OFF";
  if(livePreview) {
    toast("üé≠ Live avatar preview enabled");
  } else {
    toast("‚è∏Ô∏è Live preview paused");
    ctx.clearRect(0, 0, els.fx.width / devicePixelRatio, els.fx.height / devicePixelRatio);
  }
});

// Capture
els.shotBtn.addEventListener('click', ()=>{
  const tmp = document.createElement('canvas');
  const r = els.fx.getBoundingClientRect();
  tmp.width = r.width * devicePixelRatio; tmp.height = r.height * devicePixelRatio;
  const tctx = tmp.getContext('2d');
  tctx.save();
  if(mirrored){
    tctx.translate(tmp.width,0); tctx.scale(-1,1);
  }
  tctx.drawImage(els.video, 0, 0, tmp.width, tmp.height);
  tctx.restore();
  tctx.drawImage(els.fx, 0, 0, tmp.width, tmp.height);

  tmp.toBlob(b=>{
    const url = URL.createObjectURL(b);
    addThumb(url);
    const a = document.createElement('a'); a.href=url; a.download=`mythic_eyes_${Date.now()}.png`; a.click();
    toast("Captured!");
  }, "image/png");
});

function addThumb(url){
  const d = document.createElement('div'); d.className="thumb";
  const img = new Image(); img.src = url; img.style.width="100%"; img.style.height="100%"; img.style.objectFit="cover";
  d.appendChild(img);
  d.onclick = ()=>{ const a=document.createElement('a'); a.href=url; a.download='mythic_eyes.png'; a.click(); };
  els.gallery.prepend(d);
}


async function stopCamera(){
  const s = els.video.srcObject;
  if(s){ s.getTracks().forEach(t=>t.stop()); els.video.srcObject = null; }
}

(async function boot(){
  try {
    await initFace();
    await openCamera();
    sizeCanvas();
    requestAnimationFrame(predictLoop);
  } catch(error) {
    console.error('Boot error:', error);
    els.status.textContent = "Initialization failed";
    toast("App failed to start: " + error.message);
  }
})();
</script>
</body>
</html>